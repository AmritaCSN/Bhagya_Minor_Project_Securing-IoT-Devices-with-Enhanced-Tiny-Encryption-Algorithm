import math
from collections import Counter
import hashlib

# Function to compute SHA-256 hash (used in enhanced TEA)
def compute_sha256_hash(plaintext):
    hash_obj = hashlib.sha256(plaintext.encode())
    full_hash = hash_obj.digest()
    return full_hash[:16], full_hash[16:]

# XOR function for key segments
def xor_with_key(hash_segments, key_segments):
    return [int.from_bytes(hash_seg, 'big') ^ key_seg for hash_seg, key_seg in zip(hash_segments, key_segments)]

# Enhanced TEA encryption with dynamic key scheduling and key storage for decryption
def enhanced_tea_encrypt(plaintext_block, key, round_keys_store):
    v0 = int.from_bytes(plaintext_block[:4], 'big')
    v1 = int.from_bytes(plaintext_block[4:], 'big')

    k0 = int.from_bytes(key[:4], 'big')
    k1 = int.from_bytes(key[4:8], 'big')
    k2 = int.from_bytes(key[8:12], 'big')
    k3 = int.from_bytes(key[12:], 'big')

    delta = 0x9e3779b9
    sum = 0

    hash_value1, hash_value2 = compute_sha256_hash(plaintext_block.decode(errors='ignore'))
    first_half_segments = [hash_value1[i:i+4] for i in range(0, 16, 4)]
    second_half_segments = [hash_value2[i:i+4] for i in range(0, 16, 4)]

    for i in range(32):
        if i % 2 == 0:
            # Use first 128-bit hash for even rounds
            key_segments = xor_with_key(first_half_segments, [k0, k1, k2, k3])
        else:
            # Use second 128-bit hash for odd rounds
            key_segments = xor_with_key(second_half_segments, [k0, k1, k2, k3])

        round_keys_store.append(key_segments)  # Store key segments for decryption

        sum = (sum + delta) & 0xffffffff
        v0 = (v0 + (((v1 << 4) + key_segments[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key_segments[1]))) & 0xffffffff
        v1 = (v1 + (((v0 << 4) + key_segments[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key_segments[3]))) & 0xffffffff

    ciphertext_block = v0.to_bytes(4, 'big') + v1.to_bytes(4, 'big')
    return ciphertext_block

# Function to calculate Shannon entropy of ciphertext
def calculate_entropy(data):
    # Count the frequency of each byte in the data
    byte_counts = Counter(data)
    # Total number of bytes in the data
    total_bytes = len(data)
    
    # Calculate entropy using the Shannon entropy formula
    entropy = 0.0
    for count in byte_counts.values():
        # Probability of each byte
        prob = count / total_bytes
        entropy -= prob * math.log2(prob)
    
    return entropy

# Function to handle larger plaintext sizes with key storage
def encrypt_large_plaintext(plaintext, key):
    blocks = [plaintext[i:i+8] for i in range(0, len(plaintext), 8)]
    ciphertext = b""
    round_keys_store = []  # Store round keys for each block

    for block in blocks:
        if len(block) < 8:
            block = block.ljust(8, b'\x00')
        ciphertext += enhanced_tea_encrypt(block, key, round_keys_store)

    return ciphertext

# Example plaintext and key
plaintext = "Entropy analysis is an important method to evaluate the randomness and unpredictability of an encryption algorithm. By performing entropy analysis, you can assess how resistant your algorithm is to patterns or predictability, which is essential for ensuring secure encryption. To perform entropy analysis on your encryption algorithm, you will primarily be measuring the Shannon entropy of the ciphertext generated by your algorithm. Higher entropy values indicate that the ciphertext is more random and secure. The ideal entropy value should approach 8 bits per byte (i.e., 256-bit entropy for each 8-byte block of ciphertext), suggesting that the encryption is providing strong randomness."
key = b"0123456789abcdef"  # 16-byte key for TEA

# Encrypt the plaintext
ciphertext = encrypt_large_plaintext(plaintext.encode(), key)

# Calculate the entropy of the ciphertext
entropy_value = calculate_entropy(ciphertext)
print(f"Entropy of the ciphertext: {entropy_value:.4f} bits per byte")

